package main

import (
	"fmt"
	"github/invokerw/gintos/proto/rbac"
	"google.golang.org/genproto/googleapis/api/annotations"
	"google.golang.org/protobuf/compiler/protogen"
	"google.golang.org/protobuf/proto"
	"html/template"
	"net/http"
	"os"
	"path/filepath"
)

const tplRBAC = `// Code generated by protoc-gen-go-gin. DO NOT EDIT.
// - protoc-gen-go-gin Version: {{.Version}}
package {{.PackageName}}

import (
	"github/invokerw/gintos/proto/rbac"
)

var (
	ApiInfo []*rbac.ApiInfo
	ApiTypeMap map[string][]*rbac.ApiInfo
	ApiMap  map[string]*rbac.ApiInfo // key: name
	ApiPathMethodToApiInfo map[string]*rbac.ApiInfo // key: path-method
)

func init() {
	ApiInfo = getApiInfoList()
	ApiTypeMap = make(map[string][]*rbac.ApiInfo)
	ApiMap = make(map[string]*rbac.ApiInfo, len(ApiInfo))
	ApiPathMethodToApiInfo = make(map[string]*rbac.ApiInfo, len(ApiInfo))
	for _, v := range ApiInfo {
		ApiMap[v.Name] = v
		ApiPathMethodToApiInfo[v.Path+"-"+v.Method] = v
		if _, ok := ApiTypeMap[v.Type]; !ok {
			ApiTypeMap[v.Type] = make([]*rbac.ApiInfo, 0)
		}
		ApiTypeMap[v.Type] = append(ApiTypeMap[v.Type], v)
	}
}

func GetApiInfo(path, method string) (*rbac.ApiInfo, bool) {
	info, ok := ApiPathMethodToApiInfo[path+"-"+method]
	return info, ok
}

func getApiInfoList() []*rbac.ApiInfo {
	return []*rbac.ApiInfo{
		{{- range .ApiInfo }}
		{
			Method: "{{.Method}}",
			Path: "{{.Path}}",
			Name: "{{.Name}}",
			Type: "{{.Type}}",
		},
		{{- end }}
	}
}

`

func rbacGenerate(gen *protogen.Plugin, savePath, packageName string, omitempty bool, omitemptyPrefix string) error {
	if err := os.MkdirAll(savePath, 0755); err != nil {
		return err
	}
	saveFilePath := filepath.Join(savePath, "rbac.go")
	var apiInfoList []*rbac.ApiInfo
	apiMap := make(map[string]*rbac.ApiInfo)
	apiNameMap := make(map[string]*rbac.ApiInfo)
	addApiInfo := func(info *rbac.ApiInfo) {
		apiMapKey := fmt.Sprintf("%s-%s", info.Method, info.Path)
		if oldInfo, ok := apiMap[apiMapKey]; ok {
			fmt.Printf("WARNING !!!! jump duplicate api info: %v, new %v\n", oldInfo, info)
			return
		}
		if oldInfo, ok := apiNameMap[info.Name]; ok {
			fmt.Printf("WARNING !!!! jump duplicate api info: %v, new %v\n", oldInfo, info)
			return
		}
		apiInfoList = append(apiInfoList, info)
		apiMap[apiMapKey] = info
		apiNameMap[info.Name] = info
	}
	for _, f := range gen.Files {
		if !f.Generate {
			continue
		}
		for _, service := range f.Services {
			for _, method := range service.Methods {
				if method.Desc.IsStreamingClient() || method.Desc.IsStreamingServer() {
					continue
				}
				comment, ok := proto.GetExtension(method.Desc.Options(), rbac.E_Comment).(string)
				if !ok || comment == "" {
					continue
				}
				typ, ok := proto.GetExtension(method.Desc.Options(), rbac.E_Type).(string)
				if !ok || typ == "" {
					typ = "common"
				}
				rule, ok := proto.GetExtension(method.Desc.Options(), annotations.E_Http).(*annotations.HttpRule)
				if rule != nil && ok {
					for _, bind := range rule.AdditionalBindings {
						path, m := getPathAndMethod(service, method, bind, omitemptyPrefix)
						api := &rbac.ApiInfo{
							Method: m,
							Path:   path,
							Name:   comment,
							Type:   typ,
						}
						addApiInfo(api)
					}
					path, m := getPathAndMethod(service, method, rule, omitemptyPrefix)
					api := &rbac.ApiInfo{
						Method: m,
						Path:   path,
						Name:   comment,
						Type:   typ,
					}
					addApiInfo(api)
				} else if !omitempty {
					path := fmt.Sprintf("%s/%s/%s", omitemptyPrefix, service.Desc.FullName(), method.Desc.Name())
					api := &rbac.ApiInfo{
						Method: http.MethodPost,
						Path:   path,
						Name:   comment,
						Type:   typ,
					}
					addApiInfo(api)
				}
			}
		}
	}

	// 生成文件
	file, err := os.Create(saveFilePath)
	if err != nil {
		return err
	}
	defer file.Close()

	tmpl, err := template.New("rbac").Parse(tplRBAC)
	if err != nil {
		return err
	}

	data := struct {
		PackageName string
		ApiInfo     []*rbac.ApiInfo
		Version     string
	}{
		PackageName: packageName,
		ApiInfo:     apiInfoList,
		Version:     release,
	}

	if err := tmpl.Execute(file, data); err != nil {
		return err
	}

	return nil
}
